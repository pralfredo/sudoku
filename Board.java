/**
 * File: Board.java
 * Author: Pramithas Upreti
 * CS231
 * Section A
 * Project 5--> A Sudoku Solver
 * Date: Mar 16 2023
 * Purpose: This class represents a Sudoku board, consisting of a 2D array of cells.
 * The class provides methods for getting and setting cells, checking if a cell is locked, 
 * getting the number of locked cells on the board, and checking the validity of a value at a given row and column.
 */
import java.io.FileReader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.util.Random;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;

public class Board {
    private Cell[][] board;
    public static final int SIZE = 9;
    public boolean finished;
    /** Size of the smaller squares on board */
    private int sqrtSize = 3;

    /**
     * Constructs an empty board, where each cell has a value of 0 and is not
     * locked.
     */
    public Board() {
        board = new Cell[SIZE][SIZE];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                board[i][j] = new Cell(i, j, 0, false);
            }
        }
        finished = false;
    }

    /**
     * Constructs a board from a file, where each line of the file represents a row
     * of the board.
     * Each row contains nine space-separated integers, where 0 represents an empty
     * cell.
     * 
     * @param file the name of the file containing the board
     * @throws FileNotFoundException if the file cannot be found
     * @throws IOException           if there is an error reading the file
     */
    public Board(String file) {
        board = new Cell[SIZE][SIZE];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                board[i][j] = new Cell(i, j, 0);
            }
        }
        read(file);
    }

    /**
     * Constructs a random board with a given number of locked cells.
     * The board is generated by setting random cells to random values,
     * and then checking if the board is solvable. If the board is solvable,
     * a given number of cells are locked, and the board is returned.
     * If the board is not solvable, a new board is generated.
     * 
     * @param lockedCell the number of cells to lock on the board
     */
    public Board(int lockedCell) {
        this();
        Random random = new Random();
        int currentLockedCell = 0;
        while (currentLockedCell < lockedCell) {
            // generate random coordinates
            int randomRow = random.nextInt(9);
            int randomCol = random.nextInt(9);
            // if random cell is not an existing cell
            if (get(randomRow, randomCol).getValue() == 0) {
                // generate new value
                int randomValue = random.nextInt(9) + 1;
                // check if value is valid
                while (!validValue(randomRow, randomCol, randomValue)) {
                    randomValue = random.nextInt(9) + 1;
                }
                // set value and lock random cell
                set(randomRow, randomCol, randomValue, true);
                // increase number of locked cell
                currentLockedCell++;
            }
        }
        // System.out.println(this);
    }

    /**
     * Returns the number of columns
     * @return columns
     */
    public int getCols() {
        return SIZE;
    }

    /**
     * Returns the number of rows
     * @return rows
     */
    public int getRows() {
        return SIZE;
    }

    // returns the Cell at the given row and col
    public Cell get(int r, int c) {
        return board[r][c];
    }

    // returns whether the Cell at r, c, is locked
    public boolean isLocked(int r, int c) {
        return board[r][c].isLocked();
    }

    // returns the number of locked Cells on the board
    public int numLocked() {
        int numLocked = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j].isLocked()) {
                    numLocked++;
                }
            }
        }
        return numLocked;
    }

    // returns the value at Cell r, c
    public int value(int r, int c) {
        return board[r][c].getValue();
    }

    // sets the Cell at the given row and col to the given value
    public void set(int r, int c, int value) {
        board[r][c].setValue(value);
    }

    // sets the value and locked fields of the Cell at r, c
    public void set(int r, int c, int value, boolean locked) {
        board[r][c].setValue(value);
        board[r][c].setLocked(locked);
    }

    /**
     * Sets the locked status of the cell at the specified row and column.
     * 
     * @param row    the row of the cell to set
     * @param col    the column of the cell to set
     * @param locked the new locked status of the cell
     */
    public void set(int r, int c, boolean locked) {
        board[r][c].setLocked(locked);
    }

    // tests if the given value is a valid value at the given row and column of the
    // board
    public boolean validValue(int row, int col, int value) {
        boolean validValue = true;
        // check if in range [1,9]
        if (value < 1 || value > 9) {
            validValue = false;
        }
        for (int i = 0; i < 9; i++) {
            // check if unique in row
            if (board[row][i].getValue() == value && i != col) {
                validValue = false;
            }
            // check if unique in column
            if (board[i][col].getValue() == value && i != row) {
                validValue = false;
            }
        }
        // check if unique in square
        int rowDiv = row / 3;
        int colDiv = col / 3;
        for (int i = rowDiv * 3; i < (rowDiv * 3 + 3); i++) {
            for (int j = colDiv * 3; j < (colDiv * 3 + 3); j++) {
                if (board[i][j].getValue() == value && (i != row || j != col)) {
                    validValue = false;
                }
            }
        }
        return validValue;
    }

    // test if the board is solved
    public boolean validSolution() {
        boolean validSolution = true;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j].getValue() < 1 || board[i][j].getValue() > 9
                        || !validValue(i, j, board[i][j].getValue())) {
                    validSolution = false;
                }
            }
        }
        return validSolution;
    }

    // find the number of empty cell
    public int emptyCell() {
        int emptyCell = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j].getValue() == 0) {
                    emptyCell++;
                }
            }
        }
        return emptyCell;
    }

    // read files
    public boolean read(String filename) {
        try {
            // assign to a variable of type FileReader a new FileReader object, passing
            // filename to the constructor
            FileReader fr = new FileReader(filename);
            // assign to a variable of type BufferedReader a new BufferedReader, passing the
            // FileReader variable to the constructor
            BufferedReader br = new BufferedReader(fr);
            // assign to a variable of type String line the result of calling the readLine
            // method of your BufferedReader object.
            String line = br.readLine();
            // start a while loop that loops while line isn't null
            int currentRow = 0;
            System.out.println(board.toString());
            while (line != null) {
                // print line
                System.out.println(line);
                // assign to an array of Strings the result of splitting the line up by spaces
                // (line.split("[ ]+"))
                String[] array = line.split("[ ]+");
                // print the size of the String array (you can use .length)
                System.out.println(array.length);
                // use the line to set various Cells of this Board accordingly
                for (int i = 0; i < array.length; i++) {
                    board[currentRow][i].setValue(Integer.parseInt(array[i]));
                }
                currentRow++;
                // assign to line the result of calling the readLine method of your
                // BufferedReader object
                line = br.readLine();
            }
            // call the close method of the BufferedReader
            br.close();
            return true;
        } catch (FileNotFoundException ex) {
            System.out.println("Board.read():: unable to open file " + filename);
        } catch (IOException ex) {
            System.out.println("Board.read():: error reading file " + filename);
        }
        return false;
    }

    /**
     * Returns a string representation of this board. The string will contain the
     * current values in each cell, with zeroes indicating empty cells.
     * 
     * @return a string representation of this board
     */
    @Override
    public String toString() {
        String returnBoard = new String();
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                returnBoard += board[i][j] + " ";
                if (j == 2 || j == 5) {
                    returnBoard += "| ";
                }
                if (j == 8) {
                    returnBoard += "\n";
                }
            }
            if (i == 2 || i == 5) {
                for (int k = 0; k < 11; k++) {
                    returnBoard += "- ";
                }
                returnBoard += "\n";
            }
        }
        return returnBoard;
    }

    /**
     * Draws the board to the given graphics object, with the top-left corner of the
     * board at the given x,y coordinate.
     * 
     * @param g the graphics object to draw to
     * @param x the x-coordinate of the top-left corner of the board
     * @param y the y-coordinate of the top-left corner of the board
     */
    public void draw(Graphics g, int scale) {
        int offset = 5;
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, scale * SIZE, scale * (SIZE + 2));
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                board[i][j].draw(g, j * scale + offset, i * scale + 10, scale);
                if ((j + 1) % sqrtSize == 0) {
                    g.setColor(Color.WHITE);
                    g.drawLine(i * scale + 2, (j + 1) * scale + offset * 2, (i + 1) * scale - 2,
                            (j + 1) * scale + offset * 2);
                }
                if ((i + 1) % sqrtSize == 0) {
                    g.setColor(Color.WHITE);
                    g.drawLine((i + 1) * scale, j * scale + offset * 2 + 2, (i + 1) * scale,
                            (j + 1) * scale + offset * 2 - 2);
                }
            }
        }
        String successText = "Found a solution!";
        String failText = "No solution";
        if (finished) {
            g.setFont(new Font("Times New Roman", Font.BOLD, scale * sqrtSize / 3));
            if (validSolution()) {
                g.setColor(Color.GREEN);
                g.drawChars(successText.toCharArray(), 0, successText.length(), offset, (scale + 1) * (SIZE + 1));
            } else {
                g.setColor(Color.ORANGE);
                g.drawChars(failText.toCharArray(), 0, failText.length(), offset, (scale + 1) * (SIZE + 1));
            }
        }
    }
}